## Homework Assignment 4

Due Tuesday, May. 25, 2021 at 9:00 am

2019314211 Minhyun Lee



The purpose of this assignment is to explore **high dynamic range (HDR) imaging** and **tonemapping**.



### 1. HDR IMAGING (50 POINTS)

**Convert the RAW .NEF images into linear 16-bit .TIFF images using** `dcraw`.

The flags and command line to converting process.

```
-w        Use camera white balance, if possible
-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)
-q [0-3]  Set the interpolation quality
-4        Linear 16-bit, same as "-6 -W -g 1 1"
-T        Write TIFF instead of PPM

$ dcraw -w -o 1 -q 3 -4 -T ./data/door stack/exposure*.nef
```



#### LINEARIZE RENDERED IMAGES (25 POINTS)

Since the rendered images are **non-linear**, we should **convert** them **into** **linear ones** **to merge them into an HDR image**. For this, we should obtain the function *g* . Using the `gsolve.m` code introduced in the lecture, I get the function *g* and the results are shown below with two weighting scheme (e.g., uniform, tent). 

```matlab
    % Construct Z matrix for gsolve function
    Z = zeros(pixel_num, img_num, 3);

    for i = 1:img_num
        for c = 1:3
            Z(:, i, c) = imgs_small{i}(pixel_indices + (c - 1) * pixel_num);
        end
    end

    g = zeros(256, 3);
    lnE = zeros(srow * scol, 3);
    
    % Solve the least-squares optimization problem of Equation (2)
    for c = 1:3
        [g(:, c), lnE(:, c)] = gsolve(Z(:,:,c), B, l, w);
    end

```

####	Result

#### ![1](https://github.com/gaviotas/cp_project/blob/main/A4/figures/1.png?raw=true)

![2](https://github.com/gaviotas/cp_project/blob/main/A4/figures/2.png?raw=true)



#### MERGE EXPOSURE STACK INTO HDR IMAGE (15 POINTS)

In this step, I implement create 8 HDR images : ( raw and rendered ) x ( linear and logarithmic ) x ( uniform and tent ) using the Equations (5) and (6) and store the resulting HDR images as .HDR files with `hdrwrite` function. I set the clipping values `Zmin` and `Zmax` as 0.01 and 0.95, respectively.

```matlab
function [ imgHDR ] = hdr_merging( imgs, g, ln_t, weight, IMAGE_TYPE, MERGING_SCHEME )

    img_num = size(imgs, 2);
    [height, width, channel] = size(imgs{1});

    imgHDR = zeros(height, width, channel);

    for c = 1:channel
        for h = 1:height
            for w = 1:width
                num = 0;
                denom = 0;
                for k = 1:img_num
                    I_cur = imgs{k}(h, w, c);
                    w_cur = weight(I_cur + 1);
                    ln_t_cur = ln_t(k);                    
                    
                    if strcmp(IMAGE_TYPE, 'rendered')
                        I_cur = exp(g(I_cur + 1));
                    elseif strcmp(IMAGE_TYPE, 'raw')
                        I_cur = I_cur / 255.;
                    end

                    denom = denom + w_cur;
                    
                    if strcmp(MERGING_SCHEME, 'linear')
                        num = num + w_cur * I_cur / exp(ln_t_cur);
                    elseif strcmp(MERGING_SCHEME, 'logarithmic')
                        num = num + w_cur * (log(I_cur) - ln_t_cur);
                    end                                     
                end
                imgHDR(h, w, c) = num / denom;                
            end
        end
    end
    
    if strcmp(MERGING_SCHEME, 'logarithmic')
        imgHDR = exp(imgHDR);
    end                                     

    % remove NAN or INF
    idx = find(isnan(imgHDR) | isinf(imgHDR));
    imgHDR(idx) = 0;    
end
```



#### EVALUATION (10 POINTS)

To evaluate the results of the created HDR images, I **check its linearity using the color checker**. To obtain the positions of the neutral patches, I use the function `impixelinfo`.  Then, using the `fitlm` function, I perform **linear regression** to the logarithms of these six average luminances and compute **R-squared** as shown below. Except for the case (raw / tent / logarithmic), It shows a significant **R-squared** value in most cases. All of them, the case (rendered / tent / logarithmic) shows the best q-squared value, thus I use this HDR image as the following tonemapping experiments.

```matlab
% EVALUATION (10 POINTS)
if DO_EVALUATION
    tl = [375 62; 376 78; 376 93; 377 110; 377 125; 378 141;];
    br = [387 73; 388 89; 388 105; 388 122; 389 138; 390 153;];
    
    imgHDR = hdrread(hdr_path);
    img_XYZ = rgb2xyz(imgHDR, 'Colorspace', 'linear-rgb');
    
    L = img_XYZ(:,:,2);

    L_x = zeros(6, 1);
    L_y = zeros(6, 1);
    
    for i = 1:6       
        L_y(i) = log(mean(mean(L(tl(i,2):br(i,2), tl(i,1):br(i,1)))));
        L_x(i) = i;
    end
    
    mdl = fitlm(L_x, L_y);
end
```

####	Result

![3](https://github.com/gaviotas/cp_project/blob/main/A4/figures/3.png?raw=true)



### 2. TONEMAPPING (50 POINTS)



#### PHOTOGRAPHIC TONEMAPPING (20 POINTS)

In this step, I implement the tonemapping operator proposed by Reinhard et al. For displaying HDR images and apply it to my RGB images in two ways: (1) RGB color channel separately and (2) only the luminance channel Y. The parameters used is as follows. As shown in below, applying the photographic tonemapping into RGB color channel separately looks more natural.

```matlab
if DO_PHOTOGRAPHIC_TONEMAPPING
    % parameters of phtographic tonemapping
    K_rgb = 0.7;
    B_rgb = 0.9;
    K_xyY = 0.15;
    B_xyY = 0.95;
    imgHDR = double(hdrread(hdr_path));

    imgTMP_rgb = photographic_tonemapping(imgHDR, K_rgb, B_rgb, 'rgb');
    imgTMP_xyY = photographic_tonemapping(imgHDR, K_xyY, B_xyY, 'xyY');
```

```matlab
function [ imgTMP ] = photographic_tonemapping( imgHDR, K, B, colorSpace )
    % parameters
    N = size(imgHDR, 1) * size(imgHDR, 2);
    e = 1e-6;
    [height, width, channel] = size(imgHDR);
	
	% rgb colorspace
    if strcmp(colorSpace, 'rgb')
        imgTMP = zeros(height, width, channel);
        
        for c = 1:channel
            I_HDR = imgHDR(:,:,c);
            I_m_HDR = exp(mean(mean(log(I_HDR + e))));

            I_HDR_ = (K / I_m_HDR) * I_HDR;
            I_white_ = B * max(max(I_HDR_));

            I_HDR_tonemapping = I_HDR_ .* (1 + I_HDR_ / (I_white_ * I_white_)) ./ (1 + I_HDR_);

            imgTMP(:,:,c) = I_HDR_tonemapping;
        end
        
	% xyY colorspace
		...
```

####	Result

![4](https://github.com/gaviotas/cp_project/blob/main/A4/figures/4.png?raw=true)

#### TONEMAPPING USING BILATERAL FILTERING (30 POINTS)

Additionally, I implement the tonemapping using bilateral filtering. The parameters used and the results are shown below. Compared to the results without bilateral filtering, bilateral filtering emphasizes the edges of the image. I prefer tonemapping using bilateral filtering in RGB channel separately the most in terms of getting the edges of the image more accurate.

```matlab
if DO_TONEMAPPING_USING_BILATERAL_FILTERING
    % parameters of tonmapping using bilateral filtering
    kernel_size = 5;
    S_rgb = 0.20;
    sigma_d = 2;
    sigma_r = 0.2;
    imgHDR = double(hdrread(hdr_path));

    imgTMP_rgb = tonemapping_using_bilateral_filtering(imgHDR, kernel_size, S_rgb, sigma_d, sigma_r, 'rgb');
    imgTMP_xyY = tonemapping_using_bilateral_filtering(imgHDR, kernel_size, S_rgb, sigma_d, sigma_r, 'xyY');
```

```matlab
function [ imgTM ] = tonemapping_using_bilateral_filtering( imgHDR, kernel_size, S, sigma1, sigma2, colorSpace )
    % parameters
    N = size(imgHDR, 1) * size(imgHDR, 2);
    e = 1e-6;
    [height, width, channel] = size(imgHDR);

    % rgb colorspace
    if strcmp(colorSpace, 'rgb')
        imgTM = zeros(height, width, channel);
        
        for c = 1:channel
            L = log(imgHDR(:,:,c) + e);
            L_min = min(min(L));
            L_max = max(max(L));
            
            L_temp = (L - L_min) / (L_max - L_min);
            % bilateral filtering
            B_temp = bfilter2(L_temp, kernel_size, [sigma1 sigma2]);
            B = B_temp * (L_max - L_min) + L_min;
            D = L - B;
            B_ = S * (B - max(max(B)));
            I_TM = exp(B_ + D);
            
            imgTM(:,:,c) = I_TM;
        end
        
	% xyY colorspace
		...
```

####	Result

![5](https://github.com/gaviotas/cp_project/blob/main/A4/figures/5.png?raw=true)
